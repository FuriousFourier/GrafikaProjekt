<html>
  <head>
    <title>Wymodelowanie uproszczonej wersji mechanizmu, np. ruchomego modelu silnika tłokowego</title>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <script src="lib/jquery-1.9.1/jquery-1.9.1.js"></script>
      <script src="lib/three.js.r58/three.js"></script>
      <script src="lib/requestAnimationFrame/RequestAnimationFrame.js"></script>
      <script src="lib/gl-matrix/gl-matrix.js"></script>
  </head>
  <body>

    <canvas id="webglcanvas" style="border: none;" width="500" height="500" background="red"></canvas>

    <script type="text/javascript">
        var renderer = null,
            scene = null,
            camera = null,
            myTime = Date.now(),
            period = 5000,
            objects = {};

        function animate() {
            //dummyRotation(objects);
            var object = objects.counterweight;
            objects.counterweight.rotation.y = - (Date.now() - myTime) / period * 2 * Math.PI;
        }

        function dummyRotation(solids) {
            for (var key in solids) {
                solids[key].rotation.z = (Date.now() - myTime) / period * 2 * Math.PI;
                solids[key].rotation.y = (Date.now() - myTime) / period * 2 * Math.PI / 2;
            }
          /**  var now = Date.now();
            var deltat = now - currentTime;
            currentTime = now;
            var fract = deltat / duration;
            var angle = Math.PI * 2 * fract;


            cylinderGeometry.rotation.y += angle;

            cylinderGeometry.rotation.z += angle;
            cylinderGeometry.rotation.x += angle; **/
        }
        function rotateScene(deltax, deltay)
        {
            camera.rotation.x += deltay / 300;
            $("#rotation").html("obrót: 0," + camera.rotation.x.toFixed(2) + ",0");
            camera.rotation.y += deltax / 300;
            $("#rotation").html("obrót: 0," + camera.rotation.y.toFixed(2) + ",0");
            //camera.rotation.z += deltax / 300;
            //$("#rotation").html("obrót: 0," + camera.rotation.z.toFixed(2) + ",0");
        }

        function scaleScene(scale)
        {
            root.scale.set(scale, scale, scale);
            $("#scale").html("skala: " + scale);
        }

        var mouseDown = false,
            pageX = 0,
            pageY = 0;

        function onMouseMove(evt)
        {
            if (!mouseDown)
                return;

            evt.preventDefault();

            var deltax = evt.pageX - pageX;
            var deltay = evt.pageY - pageY;
            pageX = evt.pageX;
            pageY = evt.pageY;
            rotateScene(deltax, deltay);
        }

        function onMouseDown(evt)
        {
            evt.preventDefault();

            mouseDown = true;
            pageX = evt.pageX;
            pageY = evt.pageY;
        }

        function onMouseUp(evt)
        {
            evt.preventDefault();

            mouseDown = false;
        }

        function addMouseHandler(canvas)
        {
            canvas.addEventListener( 'mousemove',
                function(e) { onMouseMove(e); }, false );
            canvas.addEventListener( 'mousedown',
                function(e) { onMouseDown(e); }, false );
            canvas.addEventListener( 'mouseup',
                function(e) { onMouseUp(e); }, false );
        }
        

        function doThings() {
            requestAnimationFrame(function() { doThings(); });
            renderer.render( scene, camera );

            animate();

        }

        $(document).ready(
            function() {

                var canvas = document.getElementById("webglcanvas");
                renderer = new THREE.WebGLRenderer( { canvas: canvas, antialias: true } );
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0xDED5D0, 1);
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera( 45, canvas.width / canvas.height, 1, 4000 );
                scene.add(camera);

                document.body.appendChild(renderer.domElement);

                var textureFile = "images/foo.jpg";
                var texture = THREE.ImageUtils.loadTexture(textureFile);

                var light = new THREE.PointLight();
                light.position.x = 0;
                light.position.y = 0;
                light.position.z = 10;
                scene.add(light);

                var cylinderGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32, 1, false);
                var cylinderGeometry1 = new THREE.CylinderGeometry(0.1, 0.12, 0.5, 32, 1, false);
                var counterweightGeometry = new THREE.SphereGeometry(0.5, 32, 32, 0, Math.PI, 0, Math.PI);
                var material = new THREE.MeshPhongMaterial({color: 0xffeedd, side: THREE.DoubleSide, map: texture});
                objects["cylinder"] = new THREE.Mesh(cylinderGeometry, material);
                objects["cylinder1"] = new THREE.Mesh(cylinderGeometry1, material);
                objects.cylinder.position.z = -5;
                objects.cylinder.position.y = 1;
                objects.cylinder1.position.z = -3;
                objects.cylinder1.position.y = 0.11;
                objects.cylinder.name = "cylinder";
                objects.cylinder1.name = "cylinder1";
                objects["counterweight"] = new THREE.Mesh(counterweightGeometry, material);
                objects.counterweight.position.z = -5;
                objects.counterweight.position.y = -0.25;
                objects.counterweight.name = "counterweight";
                objects.counterweight.rotation.x = Math.PI / 2;
                //objects.counterweight.rotation.y = Math.PI / 2;

                for (var key in objects) {
                    scene.add(objects[key]);
                }

                doThings();

                // dodaje obsługę myszy, aby można było obracać scenę
                addMouseHandler(canvas);
            }
        );

    </script>
  </body>
</html>
